/**
 * Copyright 2011, Kevin Lindsey
 * See LICENSE file for licensing information
 */
package com.kevlindev.pinconverter.switches;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.kevlindev.collections.CaselessSet;
import com.kevlindev.collections.CaselessString;
import com.kevlindev.pinconverter.ExecutionContext;
import com.kevlindev.pinconverter.Registrar;
import com.kevlindev.pinconverter.commands.ICommand;
import com.kevlindev.pinconverter.model.Board;
import com.kevlindev.pinconverter.model.BusIterator;
import com.kevlindev.pinconverter.model.Configuration;
import com.kevlindev.pinconverter.model.UCF;
import com.kevlindev.text.Table;
import com.kevlindev.utils.StringUtils;

/**
 * GenerateSwitch
 * 
 * @author Kevin Lindsey
 * @version 1.0
 */
public class GenerateSwitch extends AbstractSwitch {
	/**
	 * A possibly empty list of buses to generate
	 */
	private String busList;

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.kevlindev.papilio.ISwitch#createCommand()
	 */
	@Override
	public ICommand createCommand() {
		return new ICommand() {
			private Table createTable(Board board, ExecutionContext context) {
				Table result = new Table();
				Set<String> allowedNames = getNameFilter(board);
				Set<Configuration> configuration = context.getConfiguration();

				if (configuration.contains(Configuration.COLLAPSE_COLUMNS)) {
					result.setAlignment(UCF.ADDITIONS.ordinal(), Table.Alignment.COLLAPSE);
				}

				result.setAlignment(UCF.COMMENT.ordinal(), Table.Alignment.COLLAPSE);

				// emit board to table
				board.toUCF(result, allowedNames, configuration);

				// sort table, if necessary
				if (context.isSorted()) {
					// TODO: add Comparator that takes indexes into account
					result.sort(UCF.NET.ordinal());
				}

				return result;
			}

			private void emitHeaders(Board board, ExecutionContext context, StringBuilder buffer) {
				buffer.append("# UCF file for the ").append(context.getDestinationBoardName()).append(" board").append(StringUtils.EOL);
				buffer.append("# Generated by pin_converter, written by Kevin Lindsey").append(StringUtils.EOL);
				buffer.append("# https://github.com/thelonious/papilio_pins/tree/development/pin_converter").append(StringUtils.EOL);
				buffer.append(StringUtils.EOL);

				// emit custom header
				String header = board.getHeader();

				if (header != null && header.length() > 0) {
					buffer.append(header);
				}
			}

			@Override
			public boolean execute(ExecutionContext context) {
				Board board = context.getDestinationBoard();
				boolean result = false;

				if (board != null) {
					StringBuilder buffer = new StringBuilder();

					// place wings on the board
					placeWings(board, context.getWingPlacementMap());

					// emit header
					emitHeaders(board, context, buffer);

					// emit custom config
					buffer.append(board.getConfigsString(context.getConfiguration()));

					// emit table to UCF buffer
					buffer.append(createTable(board, context).toString());

					// output result
					context.outputResult(buffer.toString());

					result = true;
				} else {
					String message;
					String boardName = context.getDestinationBoardName();

					if (boardName == null || boardName.isEmpty()) {
						message = "Unable to generate UCF file. You need to define a destination board with the -dst option";
					} else {
						// @formatter:off
						message = MessageFormat.format(
							"Unable to generate UCF file. The board you specified, ''{0}'', is not defined",
							boardName
						);
						// @formatter:on
					}

					System.err.println(message);
				}

				return result;
			}

			private void placeWings(Board board, Map<String, String> wingPlacementMap) {
				if (wingPlacementMap != null) {
					for (Map.Entry<String, String> entry : wingPlacementMap.entrySet()) {
						Board wing = Registrar.WING_REGISTRY.getBoard(entry.getValue());
						String header = entry.getKey();

						board.placeWing(wing, header);
					}
				}
			}

			private Set<String> getNameFilter(Board board) {
				Set<String> result = null;

				if (busList != null && busList.length() > 0) {
					String[] buses = StringUtils.COMMA_DELIMITER_PATTERN.split(busList);

					result = new CaselessSet(new LinkedHashSet<CaselessString>());

					for (String busText : buses) {
						if (board.containsBusName(busText) && board.getBus(busText).getPinCount() == 1) {
							result.add(busText);
						} else {
							BusIterator bus = BusIterator.getBus(busText);

							// add wing name to pass filtering in
							// Bus#toUCF(Set<String>)
							result.add(bus.getName());

							while (bus.hasNext()) {
								result.add(bus.next());
							}
						}
					}
				}

				return result;
			}
		};
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.kevlindev.papilio.ISwitch#getDescription()
	 */
	@Override
	public String getDescription() {
		return "Generate a new UCF file for the specified board.";
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.kevlindev.pinconverter.switches.ISwitch#getDisplayName()
	 */
	@Override
	public String getDisplayName() {
		return "Generate UCF";
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.kevlindev.papilio.ISwitch#getAliases()
	 */
	@Override
	public List<String> getSwitchNames() {
		List<String> aliases = new ArrayList<String>();

		aliases.add("-g");
		aliases.add("--generate");

		return aliases;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * com.kevlindev.papilio.ISwitch#processArg(com.kevlindev.papilio.PinConverter
	 * , java.util.Iterator)
	 */
	@Override
	public boolean processArg(Iterator<String> args) {
		boolean result = false;

		if (args.hasNext()) {
			String arg = args.next();

			if (!"all".equals(arg.toLowerCase())) {
				busList = arg;
			}

			result = true;
		}

		return result;
	}
}
